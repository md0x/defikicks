globalThis.require=e=>{if(e==="ethers")return ethers;throw new Error("unknown module "+e)};async function c(e){let s=await new ethers.providers.JsonRpcProvider(e).getBlockNumber(),o="DefiKicks",a=s.toString()+o,i=ethers.utils.solidityKeccak256(["string"],[a]),n=1e8-5e7;return parseInt(i,16)%n+5e7}function u(){return c(nodeUrl)}u();function p(e){return ethers.utils.keccak256(ethers.utils.toUtf8Bytes(e))}var d=async e=>{let t="https://w3s.link/ipfs/"+e;return await fetch(t).then(s=>s.text())};async function l(e,t,s){let o=[{inputs:[{internalType:"string",name:"",type:"string"}],name:"adapters",outputs:[{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"ipfsHash",type:"string"}],stateMutability:"view",type:"function"}],a=new ethers.providers.JsonRpcProvider(t),i=new ethers.Contract(s,o,a),n="";try{let r=await i.adapters(e);n=r.ipfsHash,console.log(r)}catch(r){console.error("Error:",r)}return n}var h=async()=>{let ethAddress=ethers.utils.computeAddress(publicKey);if(!adapterId)throw new Error("adapterId is required");let code=await d(adapterHash),tvl=await eval(code),currentTime=Math.floor(new Date().getTime()/1e3),response={runner:authSig.address,tvl,timestamp:currentTime},responseHash=ethers.utils.toUtf8String(ethers.utils.toUtf8Bytes(p(JSON.stringify(response)))),sigShare=await LitActions.ethPersonalSignMessageEcdsa({message:responseHash,publicKey,sigName});Lit.Actions.setResponse({response:JSON.stringify({ethAddress,response,responseHash})})};h();

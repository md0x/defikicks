globalThis.require=e=>{if(e==="ethers")return ethers;throw new Error("unknown module "+e)};function c(e){return ethers.utils.keccak256(ethers.utils.toUtf8Bytes(e))}var h=async e=>{let t="https://w3s.link/ipfs/"+e;return await fetch(t).then(r=>r.text())};async function l(e,t,r){let a=[{inputs:[{internalType:"string",name:"",type:"string"}],name:"adapters",outputs:[{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"ipfsHash",type:"string"}],stateMutability:"view",type:"function"}],i=new ethers.providers.JsonRpcProvider(t),o=new ethers.Contract(r,a,i),n="";try{let s=await o.adapters(e);n=s.ipfsHash,console.log(s)}catch(s){console.error("Error:",s)}return n}var p=async()=>{let ethAddress=ethers.utils.computeAddress(publicKey);if(!adapterId)throw new Error("adapterId is required");let code=await h(adapterHash),tvl=await eval(code),currentTime=Math.floor(new Date().getTime()/1e3),response={runner:authSig.address,tvl,timestamp:currentTime},responseHash=ethers.utils.toUtf8String(ethers.utils.toUtf8Bytes(c(JSON.stringify(response)))),sigShare=await LitActions.ethPersonalSignMessageEcdsa({message:responseHash,publicKey,sigName});Lit.Actions.setResponse({response:JSON.stringify({ethAddress,response,responseHash})})};p();
